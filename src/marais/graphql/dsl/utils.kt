package marais.graphql.dsl

import kotlinx.coroutines.Deferred
import kotlinx.coroutines.flow.Flow
import org.reactivestreams.Publisher
import java.util.concurrent.CompletionStage
import kotlin.reflect.KClass
import kotlin.reflect.KType
import kotlin.reflect.full.isSubclassOf

operator fun List<FieldSpec>.contains(name: String): Boolean {
    for (field in this) {
        if (field.name == name)
            return true
    }
    return false
}

internal fun KClass<*>.isValidClassForType(): Boolean = !(isSealed || isAbstract)

internal fun KClass<*>.isValidClassForInterface(): Boolean = isSealed || isAbstract || isOpen

/**
 * @return true if this type can coerce with a graphql list
 */
internal fun KClass<*>.coerceWithList(): Boolean = isSubclassOf(Iterable::class)

internal fun KClass<*>.isEnum() = isSubclassOf(Enum::class)

/**
 * Create a displayable name for this class for inclusion in a schema
 */
fun KClass<*>.deriveName(): String {
    return simpleName ?: throw Exception("Can't find a name for $this, please define a name explicitly")
}

/**
 * Those functions are usually not wanted in the schema.
 * write$Self is generated by kotlinx.serialization since the recent versions
 */
internal val invalidFunctionName = listOf("equals", "hashCode", "toString", "copy", "write\$Self")
internal val componentPattern = Regex("component[0-9]+")

/**
 * Blacklist known functions that are not ok in a schema
 */
internal fun String.isValidFunctionForDerive(): Boolean {
    return this !in invalidFunctionName && !componentPattern.matches(this)
}

internal fun KType.isAsyncType(): Boolean {
    return classifier == Flow::class
            || classifier == Deferred::class
            || kclass.isSubclassOf(CompletionStage::class)
            || kclass.isSubclassOf(Publisher::class)
}

internal val KType.kclass
    get() = classifier as KClass<*>

/**
 * Returns the first type argument, this won't check if that class is an actual container
 */
internal fun KType.unwrap(): KType {
    return if (arguments.size == 1) {
        arguments[0].type ?: throw Exception("No *-projection allowed")
    } else {
        throw Exception("Called unwrap on a type with a number of type arguments != 1")
    }
}

fun KType.unwrapAsyncType(): KType = if (isAsyncType()) unwrap() else this

internal val KType.name
    get() = kclass.simpleName!!

/**
 * Includes name of type arguments too
 */
internal fun KType.deepName(): String = name + arguments.map { it.type?.deepName() }.joinToString(separator = "")

/**
 * @return true if any of the type arguments is a *-projection
 */
internal fun KType.hasStarProjection(): Boolean =
    arguments.map { it.type == null }.reduceOrNull { acc, b -> acc || b } ?: false
