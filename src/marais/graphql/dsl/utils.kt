package marais.graphql.dsl

import kotlinx.coroutines.Deferred
import kotlinx.coroutines.flow.Flow
import org.reactivestreams.Publisher
import java.util.concurrent.CompletableFuture
import kotlin.reflect.KClass
import kotlin.reflect.KType
import kotlin.reflect.full.isSubclassOf
import kotlin.reflect.typeOf

operator fun List<Field>.contains(name: String): Boolean {
    for (field in this) {
        if (field.name == name)
            return true
    }
    return false
}

internal fun KClass<*>.isValidClassForType(): Boolean {
    return !(isSealed || isAbstract)
}

internal fun KClass<*>.isValidClassForInterface(): Boolean {
    return isSealed || isAbstract || isOpen
}

/**
 * @return true if this type can coerce with a graphql list
 */
internal fun KClass<*>.coerceWithList(): Boolean = isSubclassOf(Iterable::class)

/**
 * Those functions are usually not wanted in the schema.
 * write$Self is generated by kotlinx.serialization since the recent versions
 */
internal val invalidFunctionName = listOf("equals", "hashCode", "toString", "copy", "write\$Self")
internal val componentPattern = Regex("component[0-9]+")

/**
 * Blacklist known functions that are not ok in a schema
 */
internal fun String.isValidFunctionForDerive(): Boolean {
    return this !in invalidFunctionName && !componentPattern.matches(this)
}

internal val flowType = typeOf<Flow<*>>()
internal val deferredType = typeOf<Deferred<*>>()
internal val futureType = typeOf<CompletableFuture<*>>()
internal val publisherType = typeOf<Publisher<*>>()

internal fun KType.isFlow(): Boolean = classifier == flowType.classifier

internal fun KType.isAsyncType(): Boolean {
    return isFlow()
            || classifier == deferredType.classifier
            || classifier == futureType.classifier
            || classifier == publisherType.classifier
}

internal val KType.kclass
    get() = classifier as KClass<*>

/**
 * Returns the first type argument, this won't check if that class is an actual container
 */
internal fun KType.unwrap(): KType = arguments[0].type!!

internal fun KType.unwrapAsyncType(): KType = if (isAsyncType()) unwrap() else this

internal val KType.name
    get() = kclass.simpleName!!

internal val KType.deepName: String
    get() = name + arguments.map { it.type?.deepName }.joinToString(separator = "")
