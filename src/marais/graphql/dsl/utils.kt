package marais.graphql.dsl

import kotlinx.coroutines.Deferred
import kotlinx.coroutines.flow.Flow
import org.reactivestreams.Publisher
import java.util.concurrent.CompletableFuture
import kotlin.reflect.KClass
import kotlin.reflect.KType
import kotlin.reflect.KTypeProjection
import kotlin.reflect.full.createType

operator fun List<Field>.contains(name: String): Boolean {
    for (field in this) {
        if (field.name == name)
            return true
    }
    return false
}

internal fun KClass<*>.isValidClassForType(): Boolean {
    return !(isSealed || isAbstract)
}

internal fun KClass<*>.isValidClassForInterface(): Boolean {
    return isSealed || isAbstract || isOpen
}

/**
 * Those functions are usually not wanted in the schema.
 * write$Self is generated by kotlinx.serialization since the recent versions
 */
internal val invalidFunctionName = listOf("equals", "hashCode", "toString", "copy", "write\$Self")
internal val componentPattern = Regex("component[0-9]+")

/**
 * Blacklist known functions that are not ok in a schema
 */
internal fun String.isValidFunctionForDerive(): Boolean {
    return this !in invalidFunctionName && !componentPattern.matches(this)
}

internal val flowType = Flow::class.createType(listOf(KTypeProjection.STAR))
internal val deferredType = Deferred::class.createType(listOf(KTypeProjection.STAR))
internal val futureType = CompletableFuture::class.createType(listOf(KTypeProjection.STAR))
internal val publisherType = Publisher::class.createType(listOf(KTypeProjection.STAR))

internal fun KType.isFlow(): Boolean = classifier == flowType.classifier

internal fun KType.isAsyncType(): Boolean {
    return isFlow()
            || classifier == deferredType.classifier
            || classifier == futureType.classifier
            || classifier == publisherType.classifier
}

/**
 * Returns the first type argument, this won't check if that class is an actual container
 */
internal fun KType.unwrap(): KType = arguments[0].type!!

internal fun KType.unwrapAsyncType(): KType = if (isAsyncType()) unwrap() else this

internal fun KType.name(): String = (classifier!! as KClass<*>).simpleName!!
